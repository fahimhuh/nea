use self::{scene::Scene, shaders::Uniforms};

use super::frame::FrameRef;
use crate::{
    loader::SceneLoader,
    vulkan::{
        command::CommandList,
        context::Context,
        descriptor::{
            DescriptorBinding, DescriptorBufferWrite, DescriptorImageWrite, DescriptorPool,
            DescriptorSet, DescriptorSetLayout, DescriptorTLASWrite,
        },
        image::Image,
        pipeline::{ComputePipeline, PipelineLayout},
        shader::Shader,
    },
    world::World,
};
use ash::vk::{self};
use std::sync::Arc;

mod scene;
mod shaders;

mod shader {
    // Embed the raytracer shader code generated by the build script into the binary
    include!(concat!(env!("OUT_DIR"), "/raytracer.comp.rs"));
}

// The Raytracer is responsible for rendering the scene using raytracing
// It executes a compute shader that utilises hardware accelerated raytracing
// to render the scene.
pub struct Raytracer {
    // Descriptor pool for allocating descriptor sets
    descriptor_pool: DescriptorPool,
    // Descriptor set layout for the raytracer
    descriptor_layout: DescriptorSetLayout,
    // Pipeline layout for the raytracer
    pipeline_layout: PipelineLayout,
    // Compute shader for the raytracer
    shader: Shader,
    // Compute pipeline for the raytracer
    pipeline: ComputePipeline,
    // Descriptor sets for the raytracer for each frame
    descriptor_sets: Vec<DescriptorSet>,

    // The uniforms are a special buffer that is updated each frame
    // containing the camera and other scene data.
    // uniform is terminology from graphics rendering, meaning data that is constant for
    // a single frame (it can change between frames, but not during a frame).
    uniforms: Uniforms,

    // And a reference to the scene to render.
    // The scene is similar to the world,
    // however it is a more efficient representation of the world
    // and is stored on the GPU VRAM for fast access.
    scene: Option<Scene>,
}

impl Raytracer {
    pub fn new(context: Arc<Context>) -> Self {
        // Create the descriptor pool
        let descriptor_pool = DescriptorPool::new(context.clone());

        // Initialise the bindings used by the shader and create the descriptor layout
        let bindings = vec![
            DescriptorBinding {
                binding: 0,
                count: 1,
                kind: vk::DescriptorType::STORAGE_IMAGE,
                stage: vk::ShaderStageFlags::COMPUTE,
            },
            DescriptorBinding {
                binding: 1,
                count: 1,
                kind: vk::DescriptorType::UNIFORM_BUFFER,
                stage: vk::ShaderStageFlags::COMPUTE,
            },
            DescriptorBinding {
                binding: 2,
                count: 1,
                kind: vk::DescriptorType::ACCELERATION_STRUCTURE_KHR,
                stage: vk::ShaderStageFlags::COMPUTE,
            },
            DescriptorBinding {
                binding: 3,
                count: 1,
                kind: vk::DescriptorType::STORAGE_BUFFER,
                stage: vk::ShaderStageFlags::COMPUTE,
            },
        ];

        let descriptor_layout = DescriptorSetLayout::new(context.clone(), bindings);

        // Initialise the push constants for the pipeline. Push Constants are not actually used
        // by the shader, but the Vulkan abstraction layer requires them to be defined.
        let push_constants = vk::PushConstantRange {
            stage_flags: vk::ShaderStageFlags::COMPUTE,
            offset: 0,
            // Dummy size, does not really matter how large, as long as it is not zero
            size: std::mem::size_of::<u64>() as u32,
        };

        // Create the pipeline layout
        let pipeline_layout = PipelineLayout::new(
            context.clone(),
            push_constants,
            std::slice::from_ref(&descriptor_layout),
        );

        // Create a shader module from the embedded shader code
        let shader = Shader::new(
            context.clone(),
            &shader::CODE,
            vk::ShaderStageFlags::COMPUTE,
            "main",
        );

        // And create the compute pipeline
        let pipeline = ComputePipeline::new(context.clone(), &shader, &pipeline_layout);

        // Allocate descriptor sets for each frame
        let descriptor_sets = descriptor_pool.allocate(&context, &descriptor_layout, 3);

        // And initalise the GPU buffer for the uniforms
        let uniforms = Uniforms::new(context.clone());

        Self {
            descriptor_pool,
            descriptor_layout,
            pipeline_layout,
            shader,
            pipeline,
            descriptor_sets,
            uniforms,
            scene: None,
        }
    }

    pub fn run(&mut self, cmds: &CommandList, frame: &FrameRef, world: &World) {
        // Poll for a new scene to load
        if let Some(scene) = SceneLoader::poll() {
            // If a new scene is available, load it
            // and flush the old scene from the GPU
            self.scene = Some(Scene::load(frame.context.clone(), scene));
        }

        // Only raytrace if there is a scene to trace against!
        if self.scene.is_some() {
            // Run the compute pipeline
            self.raytrace(cmds, frame, world);
        }
    }

    // Internal function to record the commands for raytracing into the frame command list
    fn raytrace(&mut self, cmds: &CommandList, frame: &FrameRef, world: &World) {
        // Get the scene and update the uniforms given the new state of the world
        let scene = self.scene.as_ref().unwrap();
        let uniforms = self.uniforms.update_uniforms(frame, world);

        // Update this frames descriptor set with this frames swapchain image (to render to)
        // and the uniforms buffer
        let descriptor_set = self.descriptor_sets.get(frame.index()).unwrap();
        descriptor_set.write(
            &[DescriptorImageWrite {
                image_view: frame.display.views.get(frame.index()).unwrap(),
                layout: vk::ImageLayout::GENERAL,
                binding: 0,
                sampler: None,
                // The image kind is a storage image, which is a special kind of image
                // that can be read and written to by shaders.
                // Unlike a regular image, which can only be read from.
                image_kind: vk::DescriptorType::STORAGE_IMAGE,
            }],
            &[
                // Write the uniforms buffer to the descriptor set
                DescriptorBufferWrite {
                    buffer_kind: vk::DescriptorType::UNIFORM_BUFFER,
                    buffer: uniforms,
                    range: Uniforms::UNIFORMS_SIZE,
                    binding: 1,
                },
                // Write the materials buffer to the descriptor set
                DescriptorBufferWrite {
                    buffer_kind: vk::DescriptorType::STORAGE_BUFFER,
                    buffer: &scene.materials,
                    range: Scene::MATERIAL_BUFFER_SIZE,
                    binding: 3,
                },
            ],
        );

        // Write the scene TLAS to the descriptor set
        descriptor_set.write_tlas(DescriptorTLASWrite {
            reference: &scene.tlas,
            binding: 2,
        });

        // Transition the swapchain image to a general layout which is required for the compute shader
        let image_memory_barriers = [vk::ImageMemoryBarrier2 {
            src_stage_mask: vk::PipelineStageFlags2::NONE,
            src_access_mask: vk::AccessFlags2::NONE,
            dst_stage_mask: vk::PipelineStageFlags2::COMPUTE_SHADER,
            dst_access_mask: vk::AccessFlags2::SHADER_WRITE,
            old_layout: vk::ImageLayout::UNDEFINED,
            new_layout: vk::ImageLayout::GENERAL,
            src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            image: frame.display.images.get(frame.index()).unwrap().handle,
            subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
            ..Default::default()
        }];

        // Execute the pipeline barrier to transition the image layout
        cmds.pipeline_barrier(&image_memory_barriers, &[]);

        // Bind the pipeline and descriptor set
        cmds.bind_compute_pipeline(&self.pipeline);
        cmds.bind_descriptor_sets(
            vk::PipelineBindPoint::COMPUTE,
            &self.pipeline_layout,
            &[descriptor_set.handle],
        );

        // Run the compute shader for each pixel in the swapchain image
        cmds.dispatch(frame.display.dims.x, frame.display.dims.y, 1);

        // Transition the swapchain image back to a color attachment layout (whcih is used by the UI renderer)
        let image_memory_barriers = [vk::ImageMemoryBarrier2 {
            src_stage_mask: vk::PipelineStageFlags2::COMPUTE_SHADER,
            src_access_mask: vk::AccessFlags2::SHADER_WRITE,
            dst_stage_mask: vk::PipelineStageFlags2::NONE,
            dst_access_mask: vk::AccessFlags2::NONE,
            old_layout: vk::ImageLayout::GENERAL,
            new_layout: vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            image: frame.display.images.get(frame.index()).unwrap().handle,
            subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
            ..Default::default()
        }];

        // Execute the pipeline barrier to transition the image layout
        cmds.pipeline_barrier(&image_memory_barriers, &[]);
    }
}
