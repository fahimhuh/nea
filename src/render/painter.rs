use super::frame::FrameRef;
use crate::{
    interface::Interface,
    vulkan::{
        buffer::Buffer,
        command::{CommandList, CommandPool},
        context::Context,
        descriptor::{
            DescriptorBinding, DescriptorImageWrite, DescriptorPool, DescriptorSet,
            DescriptorSetLayout,
        },
        display::Display,
        image::{Image, ImageView, Sampler},
        pipeline::{GraphicsPipeline, PipelineLayout},
        shader::Shader,
        sync::Fence,
    },
};
use ash::vk;
use egui::{epaint::ImageDelta, TextureId};
use std::{collections::HashMap, sync::Arc};

mod shaders {
    // Embed the vertex shader code generated by the build script into the binary
    pub mod vertex {
        include!(concat!(env!("OUT_DIR"), "/interface.vert.rs"));
    }

    // Embed the fragment shader code generated by the build script into the binary
    pub mod fragment {
        include!(concat!(env!("OUT_DIR"), "/interface.frag.rs"));
    }
}

// The `EguiFrameData` struct contains the Vulkan resources required to render a single frame
// It contains the vertex and index buffers required to render the interface. We need to store
// each frame's data separately, as we need to allocate a new buffer for each frame to prevent
// race conditions when rendering.
pub struct EguiFrameData {
    vertex_buffer: Buffer,
    index_buffer: Buffer,
}

// The `EguiTextureData` struct contains the Vulkan resources required to render a single texture
pub struct EguiTextureData {
    image: Image,
    view: ImageView,
    descriptor_set: DescriptorSet,
    dims: glam::UVec3,
}

// The `EguiPushConstants` struct is used to pass the dimensions of the interface to the vertex shader
#[derive(bytemuck::Zeroable, bytemuck::Pod, Clone, Copy)]
#[repr(C)]
pub struct EguiPushConstants {
    dimensions: glam::Vec2,
}

// The `InterfacePainter` struct contains the Vulkan resources required to render the interface
pub struct InterfacePainter {
    // The command pool used to allocate transfer commands, and is seperate from the main command pool
    // as we may need to allocate multiple transfer commands at once, and we don't want to block the main
    // command pool.
    transfer_command_pool: CommandPool,
    // The descriptor pool is used to allocate descriptor sets
    descriptor_pool: DescriptorPool,
    // The descriptor set layout is used to define the layout of the descriptor sets that are used
    // to bind resources to the interface shaders
    descriptor_set_layout: DescriptorSetLayout,
    // The pipeline layout is used to define the layout of the pipeline that is used to render the interface
    pipeline_layout: PipelineLayout,
    // The pipeline is used to define the rendering pipeline that is used to render the interface, and utilises
    // the hardware rasteriser to render the interface
    pipeline: GraphicsPipeline,
    // The sampler is used to sample textures in the fragment shader
    sampler: Sampler,
    // The frame data is used to store the Vulkan resources required to render each frame
    frame_data: Vec<EguiFrameData>,
    // The textures hashmap is used to store the textures that are used by the interface
    textures: HashMap<egui::TextureId, EguiTextureData>,
}

impl InterfacePainter {
    // Create constants for the size of the vertex and index buffers
    const VERTEX_BUFFER_SIZE: u64 = 1024 * 1024 * 4;
    const INDEX_BUFFER_SIZE: u64 = 1024 * 1024 * 2;

    pub fn new(context: Arc<Context>, display: &Display) -> Self {
        // Initialise the transfer command pool
        let transfer_command_pool = CommandPool::new(context.clone(), context.queue_family);

        // Initialise the descriptor pool
        let descriptor_pool = DescriptorPool::new(context.clone());

        // Define the descriptor bindings
        let bindings = vec![DescriptorBinding {
            binding: 0,
            count: 1,
            kind: vk::DescriptorType::COMBINED_IMAGE_SAMPLER,
            stage: vk::ShaderStageFlags::FRAGMENT,
        }];

        // And create the descriptor set layout from the bindings
        let descriptor_set_layout = DescriptorSetLayout::new(context.clone(), bindings);

        // Define the size of the push constants used to pass the dimensions of the interface to the vertex shader
        let push_constants = vk::PushConstantRange {
            stage_flags: vk::ShaderStageFlags::VERTEX,
            offset: 0,
            size: std::mem::size_of::<f32>() as u32 * 2,
        };

        // Create the pipeline layout from the push constants and descriptor set layout
        let pipeline_layout = PipelineLayout::new(
            context.clone(),
            push_constants,
            std::slice::from_ref(&descriptor_set_layout),
        );

        // Create the shader modules from the embedded shader code
        let vert_code = shaders::vertex::CODE;
        let vert_shader = Shader::new(
            context.clone(),
            &vert_code,
            vk::ShaderStageFlags::VERTEX,
            "main",
        );

        let frag_code = shaders::fragment::CODE;
        let frag_shader = Shader::new(
            context.clone(),
            &frag_code,
            vk::ShaderStageFlags::FRAGMENT,
            "main",
        );

        // Define the layout of the vertices that are used to render the interface
        // This is defined by the egui library documentation.
        let binding = vk::VertexInputBindingDescription {
            binding: 0,
            stride: (4 * std::mem::size_of::<f32>() + 4 * std::mem::size_of::<u8>()) as u32,
            input_rate: vk::VertexInputRate::VERTEX,
        };

        let attributes = [
            vk::VertexInputAttributeDescription {
                location: 0,
                binding: 0,
                format: vk::Format::R32G32_SFLOAT,
                offset: 0,
            }, // Position
            vk::VertexInputAttributeDescription {
                location: 1,
                binding: 0,
                format: vk::Format::R32G32_SFLOAT,
                offset: 8,
            }, // UV
            vk::VertexInputAttributeDescription {
                location: 2,
                binding: 0,
                format: vk::Format::R8G8B8A8_UNORM,
                offset: 16,
            }, // Color
        ];

        // Create the vulkan data structure that defines the layout of the vertices
        let vertex_info = vk::PipelineVertexInputStateCreateInfo::builder()
            .vertex_attribute_descriptions(&attributes)
            .vertex_binding_descriptions(std::slice::from_ref(&binding))
            .build();

        // Define the format of the render output
        let render_info = vk::PipelineRenderingCreateInfo::builder()
            .color_attachment_formats(std::slice::from_ref(&display.format))
            .build();

        // And create the graphics pipeline
        let pipeline = GraphicsPipeline::new(
            context.clone(),
            &vert_shader,
            &frag_shader,
            &pipeline_layout,
            vertex_info,
            render_info,
        );

        // Initialise empty GPU buffers for each frame in flight
        let mut frame_data = Vec::new();

        for i in 0..display.frames_in_flight() {
            let frame = EguiFrameData {
                // Create an empty Vertex Buffer
                vertex_buffer: Buffer::new(
                    context.clone(),
                    Self::VERTEX_BUFFER_SIZE,
                    vk::BufferUsageFlags::VERTEX_BUFFER,
                    gpu_allocator::MemoryLocation::CpuToGpu,
                    &format!("UI Vertex Buffer {}", i),
                ),
                // Create an empty Index Buffer
                index_buffer: Buffer::new(
                    context.clone(),
                    Self::INDEX_BUFFER_SIZE,
                    vk::BufferUsageFlags::INDEX_BUFFER,
                    gpu_allocator::MemoryLocation::CpuToGpu,
                    &format!("UI Index Buffer {}", i),
                ),
            };

            frame_data.push(frame);
        }

        // Initialise a new sampler used for sampling textures in the fragment shader
        let sampler = Sampler::new(
            context.clone(),
            vk::SamplerAddressMode::CLAMP_TO_EDGE,
            vk::Filter::LINEAR,
        );

        // Return the interface painter object
        Self {
            transfer_command_pool,
            descriptor_pool,
            descriptor_set_layout,
            pipeline_layout,
            pipeline,
            frame_data,
            textures: HashMap::new(),
            sampler,
        }
    }

    // This funciotn is used to render the interface
    pub fn draw(&mut self, cmds: &CommandList, frame: &FrameRef, interface: &mut Interface) {
        // Get the last output from the interface
        let output = interface.take_last_output();

        // Update textures as requested by egui
        for (id, delta) in output.textures_delta.set {
            self.update_texture(frame, id, delta);
        }

        // Convert the swapchain image into a format that is suitable for rendering into
        // using a pipeline barrier, which transitions the image from the present layout to the
        // color attachment layout and does not continue until the transition is complete on the GPU.
        let image_memory_barriers = [vk::ImageMemoryBarrier2 {
            src_stage_mask: vk::PipelineStageFlags2::NONE,
            src_access_mask: vk::AccessFlags2::NONE,
            dst_stage_mask: vk::PipelineStageFlags2::COLOR_ATTACHMENT_OUTPUT,
            dst_access_mask: vk::AccessFlags2::COLOR_ATTACHMENT_WRITE,
            old_layout: vk::ImageLayout::UNDEFINED,
            new_layout: vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            image: frame.image().handle,
            subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
            ..Default::default()
        }];

        // execute the pipeline barrier
        cmds.pipeline_barrier(&image_memory_barriers, &[]);

        // Initialise the rendering attachment info,, which allows us to output the rendering result to the swapchain image
        let swapchain_attachment = vk::RenderingAttachmentInfo::builder()
            .image_layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL)
            .image_view(frame.image_view().handle)
            .load_op(vk::AttachmentLoadOp::LOAD)
            .store_op(vk::AttachmentStoreOp::STORE)
            .clear_value(vk::ClearValue::default());

        // Define the rendering info, which is used to define the area that is being rendered into
        let rendering_info = vk::RenderingInfo::builder()
            .render_area(vk::Rect2D {
                offset: vk::Offset2D::default(),
                extent: vk::Extent2D {
                    width: frame.display.dims.x,
                    height: frame.display.dims.y,
                },
            })
            .color_attachments(std::slice::from_ref(&swapchain_attachment))
            .layer_count(1)
            .build();

        let frame_data = self.frame_data.get_mut(frame.index()).unwrap();

        // Begin rendering commands
        cmds.begin_rendering(rendering_info);

        // Bind the graphics pipeline
        cmds.bind_graphics_pipeline(&self.pipeline);
        // And set the vertex and index buffers
        cmds.bind_vertex_buffer(&frame_data.vertex_buffer);
        cmds.bind_index_buffer(&frame_data.index_buffer);

        // Set the viewport to the size of the swapchain image
        cmds.set_viewport(
            0.0,
            0.0,
            frame.display.dims.x as f32,
            frame.display.dims.y as f32,
        );

        // Push constants to pass the dimensions of the interface to the vertex shader
        let push_constants = frame.display.dims.as_vec2() / frame.display.dpi;
        cmds.push_constants(
            &self.pipeline_layout,
            vk::ShaderStageFlags::VERTEX,
            push_constants,
        );

        // Begin copying the data needed to render this frame into the GPU buffers for rendering

        // Get pointers to the buffers
        let mut vertex_ptr = frame_data
            .vertex_buffer
            .get_ptr()
            .cast::<egui::epaint::Vertex>()
            .as_ptr();
        let mut index_ptr = frame_data.index_buffer.get_ptr().cast::<u32>().as_ptr();

        // Set the starting vertex and index
        let mut base_vertex = 0;
        let mut base_index = 0;

        // Get the shapes from egui that we need to copy
        let primitives = interface
            .context()
            .tessellate(output.shapes, frame.display.dpi);

        for primitive in primitives {
            // Get the mesh from each primitive
            let mesh = match primitive.primitive {
                egui::epaint::Primitive::Mesh(mesh) => mesh,
                _ => unimplemented!(),
            };

            // Copy the vertex and index data into the GPU buffers
            unsafe {
                vertex_ptr.copy_from_nonoverlapping(mesh.vertices.as_ptr(), mesh.vertices.len());
                vertex_ptr = vertex_ptr.add(mesh.vertices.len());

                index_ptr.copy_from_nonoverlapping(mesh.indices.as_ptr(), mesh.indices.len());
                index_ptr = index_ptr.add(mesh.indices.len());
            }

            // Bind the texture needed to rendering this shape
            let texture_data = self.textures.get(&mesh.texture_id).unwrap();
            cmds.bind_descriptor_sets(
                vk::PipelineBindPoint::GRAPHICS,
                &self.pipeline_layout,
                &[texture_data.descriptor_set.handle],
            );

            // Calculate the bounds of the shape and set the scissor to the bounds
            let min = (glam::vec2(primitive.clip_rect.min.x, primitive.clip_rect.min.y)
                * frame.display.dpi)
                .as_ivec2();
            let offset = vk::Offset2D { x: min.x, y: min.y };

            let extent = vk::Extent2D {
                width: primitive.clip_rect.width().round() as u32,
                height: primitive.clip_rect.height().round() as u32,
            };
            cmds.set_scissor(offset, extent);

            // Record the commands to draw the shape with the correct vertex and index offsets
            cmds.draw_indexed(
                mesh.indices.len() as u32,
                1,
                base_index as u32,
                base_vertex as i32,
                0,
            );

            // Add the offset to the base vertex and index
            base_vertex += mesh.vertices.len();
            base_index += mesh.indices.len();
        }
        // Finish rendering commands
        cmds.end_rendering();

        // Set the swapchain image to something suitable for showuing on the screen
        let image_memory_barriers = [vk::ImageMemoryBarrier2 {
            src_stage_mask: vk::PipelineStageFlags2::COLOR_ATTACHMENT_OUTPUT,
            src_access_mask: vk::AccessFlags2::COLOR_ATTACHMENT_WRITE,
            dst_stage_mask: vk::PipelineStageFlags2::NONE,
            dst_access_mask: vk::AccessFlags2::NONE,
            old_layout: vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            new_layout: vk::ImageLayout::PRESENT_SRC_KHR,
            src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            image: frame.display.images[frame.index()].handle,
            subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
            ..Default::default()
        }];
        cmds.pipeline_barrier(&image_memory_barriers, &[]);

        // Destroy the textures that are no longer needed
        for id in output.textures_delta.free {
            self.textures.remove(&id);
        }
    }

    // Thius function is used to update the textures on the GPU that used by the interface for rendering
    pub fn update_texture(&mut self, frame: &FrameRef, id: TextureId, delta: ImageDelta) {
        // Get the bytes of the image
        let bytes: Vec<u8> = match &delta.image {
            egui::ImageData::Color(image) => {
                image.pixels.iter().flat_map(|c| c.to_array()).collect()
            }
            egui::ImageData::Font(image) => image
                .srgba_pixels(None)
                .flat_map(|c| c.to_array())
                .collect(),
        };

        // Create a buffer that is accessible by the CPU and GPU to copy the pixels into temporarily
        let staging = Buffer::new(
            frame.context.clone(),
            bytes.len() as u64,
            vk::BufferUsageFlags::TRANSFER_SRC,
            gpu_allocator::MemoryLocation::CpuToGpu,
            "UI Staging Buffer",
        );

        // Copy the image pixels into the staging buffer
        unsafe {
            staging
                .get_ptr()
                .cast::<u8>()
                .as_ptr()
                .copy_from_nonoverlapping(bytes.as_ptr(), bytes.len())
        };

        // Create a new image and image view to store the texture with the size of the image
        // which is stored on the GPU memory
        let image = Image::new(
            frame.context.clone(),
            glam::uvec3(delta.image.width() as u32, delta.image.height() as u32, 1),
            vk::Format::R8G8B8A8_UNORM,
            vk::ImageUsageFlags::SAMPLED
                | vk::ImageUsageFlags::TRANSFER_DST
                | vk::ImageUsageFlags::TRANSFER_SRC,
            "UI Texture",
        );

        let view = ImageView::new(
            frame.context.clone(),
            &image,
            vk::Format::R8G8B8A8_UNORM,
            Image::default_subresource(vk::ImageAspectFlags::COLOR),
        );

        // Allocate a new command buffer to copy the pixels from the staging buffer into the image
        let cmds = self.transfer_command_pool.allocate();
        cmds.begin();

        // Make the image suitable for copying into
        let barrier = [vk::ImageMemoryBarrier2 {
            src_stage_mask: vk::PipelineStageFlags2::HOST,
            src_access_mask: vk::AccessFlags2::NONE,
            dst_stage_mask: vk::PipelineStageFlags2::TRANSFER,
            dst_access_mask: vk::AccessFlags2::TRANSFER_WRITE,
            old_layout: vk::ImageLayout::UNDEFINED,
            new_layout: vk::ImageLayout::TRANSFER_DST_OPTIMAL,
            src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            image: image.handle,
            subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
            ..Default::default()
        }];

        // Execute the pipeline barrier
        cmds.pipeline_barrier(&barrier, &[]);

        // Define the region of the image to copy the pixels into
        let region = vk::BufferImageCopy {
            buffer_offset: 0,
            buffer_row_length: 0,
            buffer_image_height: 0,
            image_subresource: vk::ImageSubresourceLayers {
                aspect_mask: vk::ImageAspectFlags::COLOR,
                mip_level: 0,
                base_array_layer: 0,
                layer_count: 1,
            },
            image_offset: vk::Offset3D::default(),
            image_extent: vk::Extent3D {
                width: delta.image.width() as u32,
                height: delta.image.height() as u32,
                depth: 1,
            },
        };

        // Record a copy the pixels from the staging buffer into the image
        cmds.copy_to_image(&staging, &image, &[region]);

        // and make the image suitable for sampling
        let barrier = [vk::ImageMemoryBarrier2 {
            src_stage_mask: vk::PipelineStageFlags2::TRANSFER,
            src_access_mask: vk::AccessFlags2::TRANSFER_WRITE,
            dst_stage_mask: vk::PipelineStageFlags2::VERTEX_SHADER,
            dst_access_mask: vk::AccessFlags2::SHADER_READ,
            old_layout: vk::ImageLayout::TRANSFER_DST_OPTIMAL,
            new_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
            src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
            image: image.handle,
            subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
            ..Default::default()
        }];

        // Execute the pipeline barrier
        cmds.pipeline_barrier(&barrier, &[]);
        cmds.end();

        let fence = Fence::new(frame.context.clone(), false);
        // Submit the commands to the GPU and wait for them to complete
        frame.context.submit(&[cmds], None, None, Some(&fence));
        fence.wait_and_reset();

        // Check if we need to copy the newly created texture into an existing texture (with an offset `pos`)
        if let Some(pos) = delta.pos {
            // Allocate a new command buffer to copy the pixels from the newly created texture into the existing texture
            let cmds = self.transfer_command_pool.allocate();
            cmds.begin();
            let texture_data = self.textures.get(&id).unwrap();
            // Tramnsition the existing texture and the newly created texture to a suitable layout for copyingq
            let barriers = [
                // Existing Texture
                vk::ImageMemoryBarrier2 {
                    src_stage_mask: vk::PipelineStageFlags2::FRAGMENT_SHADER,
                    src_access_mask: vk::AccessFlags2::SHADER_READ,
                    dst_stage_mask: vk::PipelineStageFlags2::TRANSFER,
                    dst_access_mask: vk::AccessFlags2::TRANSFER_WRITE,
                    old_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                    new_layout: vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                    src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
                    dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
                    image: texture_data.image.handle,
                    subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
                    ..Default::default()
                },
                // New texture we just created
                vk::ImageMemoryBarrier2 {
                    src_stage_mask: vk::PipelineStageFlags2::FRAGMENT_SHADER,
                    src_access_mask: vk::AccessFlags2::SHADER_READ,
                    dst_stage_mask: vk::PipelineStageFlags2::TRANSFER,
                    dst_access_mask: vk::AccessFlags2::TRANSFER_READ,
                    old_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                    new_layout: vk::ImageLayout::TRANSFER_SRC_OPTIMAL,
                    src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
                    dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
                    image: image.handle,
                    subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
                    ..Default::default()
                },
            ];

            cmds.pipeline_barrier(&barriers, &[]);

            // Define the region of the image to copy the pixels into
            let top_left = vk::Offset3D {
                x: pos[0] as i32,
                y: pos[1] as i32,
                z: 0,
            };
            let bottom_right = vk::Offset3D {
                x: pos[0] as i32 + delta.image.width() as i32,
                y: pos[1] as i32 + delta.image.height() as i32,
                z: 1,
            };

            let region = vk::ImageBlit {
                src_subresource: vk::ImageSubresourceLayers {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    mip_level: 0,
                    base_array_layer: 0,
                    layer_count: 1,
                },
                src_offsets: [
                    vk::Offset3D { x: 0, y: 0, z: 0 },
                    vk::Offset3D {
                        x: delta.image.width() as i32,
                        y: delta.image.height() as i32,
                        z: 1 as i32,
                    },
                ],
                dst_subresource: vk::ImageSubresourceLayers {
                    aspect_mask: vk::ImageAspectFlags::COLOR,
                    mip_level: 0,
                    base_array_layer: 0,
                    layer_count: 1,
                },
                dst_offsets: [top_left, bottom_right],
            };

            // Blit or copy the pixels from the newly created texture into the existing texture
            cmds.blit(&image, &texture_data.image, &[region]);

            // Make the existing texture suitable for sampling
            let barrier = [vk::ImageMemoryBarrier2 {
                src_stage_mask: vk::PipelineStageFlags2::TRANSFER,
                src_access_mask: vk::AccessFlags2::TRANSFER_WRITE,
                dst_stage_mask: vk::PipelineStageFlags2::FRAGMENT_SHADER,
                dst_access_mask: vk::AccessFlags2::SHADER_READ,
                old_layout: vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                new_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                src_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
                dst_queue_family_index: vk::QUEUE_FAMILY_IGNORED,
                image: texture_data.image.handle,
                subresource_range: Image::default_subresource(vk::ImageAspectFlags::COLOR),
                ..Default::default()
            }];

            cmds.pipeline_barrier(&barrier, &[]);
            cmds.end();

            // Submit the commands to the GPU and wait for them to complete
            frame.context.submit(&[cmds], None, None, Some(&fence));
            fence.wait_and_reset();
        } else {
            // If we don't need to copy the texture into an existing texture, then we can just
            // transition the texture to a suitable layout for sampling
            // and store the texture data in the textures hashmap

            // Create a descriptor set to bind the texture to the fragment shader
            let descriptor_set = self
                .descriptor_pool
                .allocate(&frame.context, &self.descriptor_set_layout, 1)
                .remove(0);

            // Write the texture to the descriptor set
            descriptor_set.write(
                &[DescriptorImageWrite {
                    image_kind: vk::DescriptorType::COMBINED_IMAGE_SAMPLER,
                    sampler: Some(self.sampler.handle),
                    layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                    image_view: &view,
                    binding: 0,
                }],
                &[],
            );

            // Store the texture data in the textures hashmap
            let texture_data = EguiTextureData {
                image,
                view,
                descriptor_set,
                dims: glam::uvec3(delta.image.width() as u32, delta.image.width() as u32, 1),
            };

            self.textures.insert(id, texture_data);
        }
    }
}
