#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_ray_tracing_position_fetch : require

#include "constants.glsl"
#include "structs.glsl"
#include "random.glsl"

layout(binding=0, rgba8) uniform image2D resultImage;
layout(binding=1) uniform UniformBlock { Uniforms data; } uniforms;
layout(binding=2) uniform accelerationStructureEXT tlas;
layout(binding=3) buffer Materials { Material materials[4096]; } materialBlock;
Globals globals;

// Returns a randomly generated 3D vector in the range [0, 1)
vec3 random() {
    return fract(pcg3d(globals.rngState) / vec3(float(0xffffffffu)));
}

// Calculates two perpendicular vectors, given a normal direction
// n.
// This implementation is based on Disney Pixar's "Building an Orthonormal Basis, Revisited",
// where the code is referenced off listing 3 of the paper, found below.
// Source : https://graphics.pixar.com/library/OrthonormalB/paper.pdf
mat3 calcONB(vec3 n) {
    float s = n.z >= 0.0 ? 1.0 : -1.0;
    float a = -1.0 / (s + n.z);
    float b = n.x * n.y * a;
    
    // Store the vectors in a 3x3 matrix
    mat3 onb;
    onb[0] = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);
    onb[1] = n;
    onb[2] = vec3(b, s + n.y * n.y * a, -n.y);
    return onb;
}

HitInfo getHitInfo(Ray ray, rayQueryEXT rayQuery) {
	HitInfo hit;
	
	vec3 v[3];
	rayQueryGetIntersectionTriangleVertexPositionsEXT(rayQuery, true, v);

	float t = rayQueryGetIntersectionTEXT(rayQuery, true);
	hit.pos = ray.origin + t * ray.dir;
	hit.normal = normalize(cross(v[1] - v[0], v[2] - v[0]));

	int index = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
	hit.material = materialBlock.materials[index];
	return hit;
}

bool intersect(Ray ray, rayQueryEXT rayQuery, out HitInfo hit) {
	rayQueryInitializeEXT(rayQuery, tlas, gl_RayFlagsOpaqueEXT, 0xFF, ray.origin, 0.0, ray.dir, 10000.0);
	while (rayQueryProceedEXT(rayQuery)) { }

	// Check if we hit an object
	if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
		hit = getHitInfo(ray, rayQuery);
		return true;
	} else {
		return false;
	}
}

vec3 pathtrace(Ray ray) {
	vec3 result = vec3(0.0);
	vec3 throughput = vec3(1.0);

	rayQueryEXT rayQuery;

	for (int i = 0; i < uniforms.data.bounces; i++) { 
		HitInfo hit;
		if (intersect(ray, rayQuery, hit)) {
			ray.origin = hit.pos;
			
			ray.dir = normalize(calcONB(hit.normal) * uniformSampleHemisphere(random().xy));
			ray.origin += ray.dir * 0.01;

			result += hit.material.emissive.rgb * throughput;
			throughput *= 2 * (hit.material.baseColor.rgb) * dot(hit.normal, ray.dir);
		} else {
			break;
		}
	}

	return result;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() {
	// Initialise global rng state
	globals.rngState = uvec3(gl_GlobalInvocationID.x ^ 1534, gl_GlobalInvocationID.y + 432812 ^ 941, 329810 * uniforms.data.seed) ^ uniforms.data.seed | uint(1);
	
	// uv-space coordinates in the range [0, 1]
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / (gl_NumWorkGroups.xy);
	// Account for the fact that the Vulkan uv-space is flipped
    uv.y = 1 - uv.y;

	// Translate the UV coordinates into screen-space (in the range [-1, 1])
	vec2 coord = uv * 2.0 - 1.0;

	vec3 color = vec3(0.0);
	for (int i = 0; i < uniforms.data.samples; i++) {
		Ray ray;
		ray.origin = uniforms.data.pos.xyz;

		// Calculate ray direction from projection matrices
		vec4 target = uniforms.data.inverseProj * vec4(coord, 1, 1);
		vec4 phi = vec4(normalize(target.xyz / target.w), 0);
		ray.dir = vec3(uniforms.data.inverseView * phi);

		// Jitter the ndc ray direction sligtly, softening the edges of surfaces
		ray.dir += (random() * 2.0 - 1.0) * 0.0001;

		color += pathtrace(ray);
	}

	color /= uniforms.data.samples;

	// Store the final result into the swapchain
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}