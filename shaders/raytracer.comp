#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_ray_tracing_position_fetch : require

#include "structs.glsl"
#include "random.glsl"

layout(binding=0, rgba8) uniform image2D resultImage;
layout(binding=1) uniform UniformBlock { Uniforms data; } uniforms;
layout(binding=2) uniform accelerationStructureEXT tlas;
Globals globals;

// Returns a randomly generated 3D vector in the range [0, 1)
vec3 random() {
    return fract(pcg3d(globals.rngState) / vec3(float(0xffffffffu)));
}

HitInfo getHitInfo(Ray ray, rayQueryEXT rayQuery) {
	HitInfo hit;
	
	vec3 v[3];
	rayQueryGetIntersectionTriangleVertexPositionsEXT(rayQuery, true, v);

	float t = rayQueryGetIntersectionTEXT(rayQuery, true);
	hit.pos = ray.origin + t * ray.dir;
	hit.normal = normalize(cross(v[1] - v[0], v[2] - v[0]));
	return hit;
}

bool intersect(Ray ray, rayQueryEXT rayQuery, out HitInfo hit) {
	rayQueryInitializeEXT(rayQuery, tlas, gl_RayFlagsOpaqueEXT, 0xFF, ray.origin, 0.0, ray.dir, 10000.0);
	while (rayQueryProceedEXT(rayQuery)) { }

	// Check if we hit an object
	if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
		hit = getHitInfo(ray, rayQuery);
		return true;
	} else {
		return false;
	}
}

vec3 pathtrace(Ray ray) {
	vec3 result = vec3(0.0);
	vec3 throughput = vec3(1.0);

	rayQueryEXT rayQuery;

	for (int i = 0; i < uniforms.data.bounces; i++) { 
		HitInfo hit;
		if (intersect(ray, rayQuery, hit)) {
			
		} else {
			
			break;
		}
	}

	return result;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() {
	// Initialise global rng state
	globals.rngState = uvec3(gl_GlobalInvocationID.x ^ 1534, gl_GlobalInvocationID.y + 432812 ^ 941, 329810 * uniforms.data.seed) ^ uniforms.data.seed | uint(1);
	
	// uv-space coordinates in the range [0, 1]
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / (gl_NumWorkGroups.xy);
	// Account for the fact that the Vulkan uv-space is flipped
    uv.y = 1 - uv.y;

	// Translate the UV coordinates into screen-space (in the range [-1, 1])
	vec2 coord = uv * 2.0 - 1.0;

	vec3 color = vec3(0.0);
	for (int i = 0; i < uniforms.data.samples; i++) {
		Ray ray;
		ray.origin = uniforms.data.pos.xyz;

		// Calculate ray direction from projection matrices
		vec4 target = uniforms.data.inverseProj * vec4(coord, 1, 1);
		vec4 phi = vec4(normalize(target.xyz / target.w), 0);
		ray.dir = vec3(uniforms.data.inverseView * phi);

		// Jitter the ndc ray direction sligtly, softening the edges of surfaces
		ray.dir += (random() * 2.0 - 1.0) * 0.0001;

		color += pathtrace(ray);
	}

	color /= uniforms.data.samples;

	// Store the final result into the swapchain
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}