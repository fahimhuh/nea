#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_ray_query : require


layout(binding=0, rgba8) uniform image2D resultImage;
layout(binding=1) uniform Uniforms { 
	uint seed; 
	uint samples;
	uint bounces;
	uint mode;

	float focal_length;
	float aperture;
	float exposure;
	float time;

	vec4 pos;

	mat4 inverseView;
	mat4 inverseProj;
} uniforms;
layout(binding = 2) uniform accelerationStructureEXT tlas;



// Global data
struct Globals { uvec3 rngState; } globals;

struct Ray {
    vec3 origin;
    vec3 dir;
};

// 3 Dimensional PRNG based on http://www.jcgt.org/published/0009/03/02/
uvec3 pcg3d(inout uvec3 v) {
    v = v * 1664525u + 1013904223u;
    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    v ^= v >> 16u;
    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    return v;
}

// Returns a randomly generated 3D vector in the range [0, 1)
vec3 random() {
    return fract(pcg3d(globals.rngState) / vec3(float(0xffffffffu)));
}

vec3 pathtrace(Ray ray) {
	vec3 result = vec3(0.0);
	vec3 throughput = vec3(1.0);

	rayQueryEXT rayQuery;

	for (int i = 0; i < uniforms.bounces; i++) { 
		rayQueryInitializeEXT(rayQuery, tlas, gl_RayFlagsOpaqueEXT, 0xFF, ray.origin, 0.0, ray.dir, 10000.0);              
		while (rayQueryProceedEXT(rayQuery)) { }

		// Check if we hit an object
		if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {


			result = vec3(1.0);
		} else {
			// If not, we have hit the sky. Shade it as such and break out of the loop.
			break;
		}
	}

	return result;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() {
	// Initialise global rng state
	globals.rngState = uvec3(gl_GlobalInvocationID.x ^ 1534, gl_GlobalInvocationID.y + 432812 ^ 941, 329810 * uniforms.seed) ^ uniforms.seed | uint(1);
	
	// uv-space coordinates in the range [0, 1]
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / (gl_NumWorkGroups.xy);
	// Account for the fact that the Vulkan uv-space is flipped
    uv.y = 1 - uv.y;

	// Translate the UV coordinates into screen-space (in the range [-1, 1])
	vec2 coord = uv * 2.0 - 1.0;

	vec3 color = vec3(0.0);

	for (int i = 0; i < uniforms.samples; i++) {
		Ray ray;
		ray.origin = uniforms.pos.xyz;

		// Calculate ray direction from projection matrices
		vec4 target = uniforms.inverseProj * vec4(coord, 1, 1);
		vec4 phi = vec4(normalize(target.xyz / target.w), 0);
		ray.dir = vec3(uniforms.inverseView * phi);

		// Jitter the ndc ray direction sligtly, softening the edges of surfaces
		ray.dir += (random() * 2.0 - 1.0) * 0.0001;

		color += pathtrace(ray);
	}

	color /= uniforms.samples;

	// Store the final result into the swapchain
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}