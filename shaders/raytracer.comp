#version 460
#extension GL_EXT_ray_query : require

// Shader Inputs (bound by the descriptor set on the CPU)
layout(binding=0, rgba8) uniform image2D resultImage;
layout(binding=1) uniform Uniforms { 
	uint seed; 
	uint samples;
	uint bounces;
	uint _dummy1;

	float focal_length;
	float aperture;
	float exposure;
	uint _dummy2;

	vec4 pos;

	mat4 inverseView;
	mat4 inverseProj;
} uniforms;
layout(binding = 2) uniform accelerationStructureEXT tlas;

// Global data
struct Globals { uvec3 rngState; } globals;

struct Ray {
    vec3 origin;
    vec3 dir;
};

// 3 Dimensional PRNG based on http://www.jcgt.org/published/0009/03/02/
uvec3 pcg3d(inout uvec3 v) {
    v = v * 1664525u + 1013904223u;
    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    v ^= v >> 16u;
    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    return v;
}

// Returns a randomly generated 3D vector in the range [0, 1)
vec3 random() {
    return fract(pcg3d(globals.rngState) / vec3(float(0xffffffffu)));
}

vec3 pathtrace(Ray ray) {
	vec3 result = vec3(0.0);
	vec3 throughput = vec3(1.0);

	for (int i = 0; i < uniforms.bounces; i++) { }
	result = ray.dir;
	return result;
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
void main() {
	// Initialise global state
	globals.rngState = uvec3(gl_GlobalInvocationID.x ^ 1534, gl_GlobalInvocationID.y + 432812 ^ 941, 329810 * uniforms.seed) ^ uniforms.seed | uint(1);
	
	// uv-space coordinates in the range [0, 1]
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / (gl_NumWorkGroups.xy);
	// Account for the fact that the Vulkan uv-space is flipped
    uv.y = 1 - uv.y;

	// Translate the UV coordinates into screen-space (in the range [-1, 1])
	vec2 coord = uv * 2.0 - 1.0;

	vec3 color = vec3(0.0);

	Ray ray;
	ray.origin = uniforms.pos.xyz;

	// Calculate ray direction from projection matrices
	vec4 target = uniforms.inverseProj * vec4(coord, 1, 1);
	vec4 phi = vec4(normalize(target.xyz / target.w), 0);
	ray.dir = vec3(uniforms.inverseView * phi);

	// Jitter the ndc ray direction sligtly, softening the edges of surfaces
	ray.dir += (random() * 2.0 - 1.0) * 0.0001;

	

	rayQueryEXT rayQuery;
  	rayQueryInitializeEXT(rayQuery,              // Ray query
                        tlas,                  // Top-level acceleration structure
                        gl_RayFlagsNoOpaqueEXT,  // Ray flags, here saying "treat all geometry as opaque"
                        0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                        ray.origin,             // Ray origin
                        0.0,                   // Minimum t-value
                        ray.dir,          // Ray direction
                        10000.0);              // Maximum t-value

	float i = 0.0;
	while (rayQueryProceedEXT(rayQuery)) { i += 1; }

  	const float t = rayQueryGetIntersectionTEXT(rayQuery, true);

	/*
	for (int i = 0; i < uniforms.samples; i++) {
		Ray ray;
		ray.origin = uniforms.pos.xyz;

		// Calculate ray direction from projection matrices
		vec4 target = uniforms.inverseProj * vec4(coord, 1, 1);
		vec4 phi = vec4(normalize(target.xyz / target.w), 0);
		ray.dir = vec3(uniforms.inverseView * phi);

		// Jitter the ndc ray direction sligtly, softening the edges of surfaces
		ray.dir += (random() * 2.0 - 1.0) * 0.0001;

		color += pathtrace(ray);
	}

	color /= uniforms.samples;
	*/

	// Store the final result into the swapchain
	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(ray.dir, 1.0));
}